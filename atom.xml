<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WHK0710</title>
  
  <subtitle>大音希声，大象无形</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://whk0710.github.io/"/>
  <updated>2018-09-27T09:12:55.397Z</updated>
  <id>http://whk0710.github.io/</id>
  
  <author>
    <name>whk0710</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashSet源码阅读记录</title>
    <link href="http://whk0710.github.io/2018/09/27/HashSet%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://whk0710.github.io/2018/09/27/HashSet源码阅读记录/</id>
    <published>2018-09-27T09:11:13.000Z</published>
    <updated>2018-09-27T09:12:55.397Z</updated>
    
    <content type="html"><![CDATA[<p>HashSet底层由HashMap完成，不允许重复值：</p><p><img src="/2018/09/27/HashSet源码阅读记录/1.png" alt=""></p><p>put操作是插入key和同一个Object：</p><p><img src="/2018/09/27/HashSet源码阅读记录/2.png" alt=""></p><p>其他操作均与hashmap相同.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HashSet底层由HashMap完成，不允许重复值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/09/27/HashSet源码阅读记录/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;put操作是插入key和同一个Object：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/201
      
    
    </summary>
    
      <category term="java源码阅读记录" scheme="http://whk0710.github.io/categories/java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>HashMap源码阅读记录</title>
    <link href="http://whk0710.github.io/2018/09/27/HashMap%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://whk0710.github.io/2018/09/27/HashMap源码阅读记录/</id>
    <published>2018-09-27T08:48:27.000Z</published>
    <updated>2018-09-27T09:06:59.418Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、要点"><a href="#一、要点" class="headerlink" title="一、要点"></a>一、要点</h3><p>1.集合类的特点</p><p>2.数据结构、初始化、构造器、初始参数</p><p>3.元素的添加</p><p>4.扩容</p><p>5.元素的获取</p><p>6.元素的删除</p><p>7.元素的遍历</p><p>8.线程不安全的表现，以及实现线程安全的HashMap</p><p>9.扩容和容量为什么是2的幂次方</p><p>*JDK1.8中的HashMap</p><h3 id="二、源码解析（jdk1-7）"><a href="#二、源码解析（jdk1-7）" class="headerlink" title="二、源码解析（jdk1.7）"></a>二、源码解析（jdk1.7）</h3><h4 id="1-集合类的特点"><a href="#1-集合类的特点" class="headerlink" title="1.集合类的特点"></a>1.集合类的特点</h4><p>散列表，由源码可知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span>&#123;</div><div class="line">    ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>继承AbstractMap，实现Map、Cloneable, Serializable支持克隆、序列化、键值对存储。此外HashMap支持插入null键值对，HashMap中的映射不是有序的，其中的方法不是同步方法，存在<strong>线程安全问题</strong>。</p><h4 id="2-数据结构、初始化、构造器、初始参数"><a href="#2-数据结构、初始化、构造器、初始参数" class="headerlink" title="2.数据结构、初始化、构造器、初始参数"></a>2.数据结构、初始化、构造器、初始参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * The default initial capacity - MUST be a power of two.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</div></pre></td></tr></table></figure><p>初始HashMap中Entry数组的length为16，注释中说，数组容量必须为2的幂次方，至于为什么后面会分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * The maximum capacity, used if a higher value is implicitly specified</span></div><div class="line"><span class="comment">     * by either of the constructors with arguments.</span></div><div class="line"><span class="comment">     * MUST be a power of two &lt;= 1&lt;&lt;30.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div></pre></td></tr></table></figure><p>Entry数组最大容量为2的30次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * The load factor used when none specified in constructor.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div></pre></td></tr></table></figure><p>负载因子，用于计算阈值 = 负载因子 * 容量，超过此阈值会造成扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * The table, resized as necessary. Length MUST Always be a power of two.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</div></pre></td></tr></table></figure><p>hashMap的核心数组，一个Entry数组用于存储键值对组成的链表，jdk1.7的hashmap的数据结构是数组+链表方式，用transient修饰，会忽略序列化.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * The number of key-value mappings contained in this map.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure><p>表示hashmap中实际键值对的总个数，用transient修饰，会忽略序列化.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * The next size value at which to resize (capacity * load factor).</span></div><div class="line"><span class="comment">     * <span class="doctag">@serial</span></span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> threshold;</div></pre></td></tr></table></figure><p>扩容的阈值，超过此值就会扩容</p><p>构造函数：</p><p>无参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></div><div class="line"><span class="comment">     * (16) and the default load factor (0.75).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>构造一个初始容量为16，负载因子为0.75的hashmap</p><p>参数构造器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></div><div class="line"><span class="comment">     * capacity and load factor.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></div><div class="line"><span class="comment">     *         or the load factor is nonpositive</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                               initialCapacity);</div><div class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                               loadFactor);</div><div class="line"></div><div class="line">        <span class="comment">// Find a power of 2 &gt;= initialCapacity</span></div><div class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</div><div class="line">            capacity &lt;&lt;= <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">        threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">        table = <span class="keyword">new</span> Entry[capacity];</div><div class="line">        useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</div><div class="line">                (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">        init();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>根据输入的初始容量initialCapacity，判断initialCapacity小于0抛异常，大于MAXIMUM_CAPACITY，initialCapacity = MAXIMUM_CAPACITY;负载因子也要符合范围，实际的容量为一个刚好超过输入initialCapacity的2的幂次方的数，构造一个table数组length=刚刚的2的幂次方。</p><h4 id="3-元素的添加"><a href="#3-元素的添加" class="headerlink" title="3.元素的添加"></a>3.元素的添加</h4><p><strong>1）put（K,V）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * Associates the specified value with the specified key in this map.</span></div><div class="line"><span class="comment">    * If the map previously contained a mapping for the key, the old</span></div><div class="line"><span class="comment">    * value is replaced.</span></div><div class="line"><span class="comment">    *</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></div><div class="line"><span class="comment">    * <span class="doctag">@param</span> value value to be associated with the specified key</span></div><div class="line"><span class="comment">    * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></div><div class="line"><span class="comment">    *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></div><div class="line"><span class="comment">    *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></div><div class="line"><span class="comment">    *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">           <span class="keyword">return</span> putForNullKey(value);</div><div class="line">       <span class="keyword">int</span> hash = hash(key);</div><div class="line">       <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">           Object k;</div><div class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">               V oldValue = e.value;</div><div class="line">               e.value = value;</div><div class="line">               e.recordAccess(<span class="keyword">this</span>);</div><div class="line">               <span class="keyword">return</span> oldValue;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       modCount++;</div><div class="line">       addEntry(hash, key, value, i);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>支持插入空键值对，判断key是否为空，是，如果table[0]处有null键值对，就覆盖，没有将该键值对插入table[0]处的链表处.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * Offloaded version of put for null keys</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</div><div class="line">                V oldValue = e.value;</div><div class="line">                e.value = value;</div><div class="line">                e.recordAccess(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        modCount++;</div><div class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>key不是空，通过hash函数获取key对应的hash值，然后通过 hash &amp; table.length-1获取桶位置，遍历当前桶位置处的链表如果key有键值对，就覆盖，否则就调用addEntry方法插入新结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * Adds a new entry with the specified key, value and hash code to</span></div><div class="line"><span class="comment">     * the specified bucket.  It is the responsibility of this</span></div><div class="line"><span class="comment">     * method to resize the table if appropriate.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Subclass overrides this to alter the behavior of put method.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</div><div class="line">            resize(<span class="number">2</span> * table.length);</div><div class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</div><div class="line">            bucketIndex = indexFor(hash, table.length);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        createEntry(hash, key, value, bucketIndex);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>addEntry方法会先判断当前size是否超过阈值并且当前桶处链表非空，就扩容，怎么扩容，下面讲。然后调用createEntry，将新结点插入当前桶位置链表的头结点处</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * Like addEntry except that this version is used when creating entries</span></div><div class="line"><span class="comment">     * as part of Map construction or "pseudo-construction" (cloning,</span></div><div class="line"><span class="comment">     * deserialization).  This version needn't worry about resizing the table.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Subclass overrides this to alter the behavior of HashMap(Map),</span></div><div class="line"><span class="comment">     * clone, and readObject.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">        size++;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p><strong>2）putAll</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * Copies all of the mappings from the specified map to this map.</span></div><div class="line"><span class="comment">     * These mappings will replace any mappings that this map had for</span></div><div class="line"><span class="comment">     * any of the keys currently in the specified map.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> m mappings to be stored in this map</span></div><div class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> numKeysToBeAdded = m.size();</div><div class="line">        <span class="keyword">if</span> (numKeysToBeAdded == <span class="number">0</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Expand the map if the map if the number of mappings to be added</span></div><div class="line"><span class="comment">         * is greater than or equal to threshold.  This is conservative; the</span></div><div class="line"><span class="comment">         * obvious condition is (m.size() + size) &gt;= threshold, but this</span></div><div class="line"><span class="comment">         * condition could result in a map with twice the appropriate capacity,</span></div><div class="line"><span class="comment">         * if the keys to be added overlap with the keys already in this map.</span></div><div class="line"><span class="comment">         * By using the conservative calculation, we subject ourself</span></div><div class="line"><span class="comment">         * to at most one extra resize.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">if</span> (numKeysToBeAdded &gt; threshold) &#123;</div><div class="line">            <span class="keyword">int</span> targetCapacity = (<span class="keyword">int</span>)(numKeysToBeAdded / loadFactor + <span class="number">1</span>);</div><div class="line">            <span class="keyword">if</span> (targetCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">                targetCapacity = MAXIMUM_CAPACITY;</div><div class="line">            <span class="keyword">int</span> newCapacity = table.length;</div><div class="line">            <span class="keyword">while</span> (newCapacity &lt; targetCapacity)</div><div class="line">                newCapacity &lt;&lt;= <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (newCapacity &gt; table.length)</div><div class="line">                resize(newCapacity);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</div><div class="line">            put(e.getKey(), e.getValue());</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>将传入的map元素插入到hashmap entry数组中，思路判断size+map.size是否超过阈值，超过就扩容；for循环put（K,V）。</p><h4 id="4-hashMap扩容"><a href="#4-hashMap扩容" class="headerlink" title="4.hashMap扩容"></a>4.hashMap扩容</h4><p>核心方法：resize</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * Rehashes the contents of this map into a new array with a</span></div><div class="line"><span class="comment">     * larger capacity.  This method is called automatically when the</span></div><div class="line"><span class="comment">     * number of keys in this map reaches its threshold.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * If current capacity is MAXIMUM_CAPACITY, this method does not</span></div><div class="line"><span class="comment">     * resize the map, but sets threshold to Integer.MAX_VALUE.</span></div><div class="line"><span class="comment">     * This has the effect of preventing future calls.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span></div><div class="line"><span class="comment">     *        must be greater than current capacity unless current</span></div><div class="line"><span class="comment">     *        capacity is MAXIMUM_CAPACITY (in which case value</span></div><div class="line"><span class="comment">     *        is irrelevant).</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</div><div class="line">        Entry[] oldTable = table;</div><div class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</div><div class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">        <span class="keyword">boolean</span> oldAltHashing = useAltHashing;</div><div class="line">        useAltHashing |= sun.misc.VM.isBooted() &amp;&amp;</div><div class="line">                (newCapacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">        <span class="keyword">boolean</span> rehash = oldAltHashing ^ useAltHashing;</div><div class="line">        transfer(newTable, rehash);</div><div class="line">        table = newTable;</div><div class="line">        threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>先保存旧数组，如果容量已经是最大就不扩容了，否则，新建一个扩容之后的数组，扩容之后的数组大小是原来的2倍，然后调用transfer方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    * Transfers all entries from current table to newTable.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</div><div class="line">           <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</div><div class="line">               Entry&lt;K,V&gt; next = e.next;</div><div class="line">               <span class="keyword">if</span> (rehash) &#123;</div><div class="line">                   e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</div><div class="line">               e.next = newTable[i];</div><div class="line">               newTable[i] = e;</div><div class="line">               e = next;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>or循环遍历每个桶处的链表，重新调整链表结点的位置，比如原来A,B在同一桶位置A-&gt;B，扩容后hash值依然相同，先遍历到A，把A方法新位置的头节点处（也可能没换位置），遍历到B就把B放到A所在位置的头节点处，也就是B-&gt;A，A,B换了头尾位置。</p><p>多线程put导致的resize可能导致线程安全问题，出现链表成环，死循环。为什么死循环下面讲。transfer是导致死循环的因素。</p><h4 id="5-元素的获取"><a href="#5-元素的获取" class="headerlink" title="5.元素的获取"></a>5.元素的获取</h4><p><strong>1）get（K）方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> getForNullKey();</div><div class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> getForNullKey();</div><div class="line">        Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span> == entry ? <span class="keyword">null</span> : entry.getValue();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>判断key为空就从table[0]桶中遍历链表，返回key==null entry的value值不为空，依然是遍历.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">     * Returns the entry associated with the specified key in the</span></div><div class="line"><span class="comment">     * HashMap.  Returns null if the HashMap contains no mapping</span></div><div class="line"><span class="comment">     * for the key.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">             e != <span class="keyword">null</span>;</div><div class="line">             e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                <span class="keyword">return</span> e;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>先通过hash函数获取hash值，然后hash &amp; table.length-1找桶位置，遍历链表，通过equals方法，如果有就返回此key对应的value。</p><h4 id="6-元素的删除"><a href="#6-元素的删除" class="headerlink" title="6.元素的删除"></a>6.元素的删除</h4><p><strong>1）remove（K）</strong></p><p>按照key删除键值对:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        Entry&lt;K,V&gt; e = removeEntryForKey(key);</div><div class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</div><div class="line">    &#125;</div><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</div><div class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">        Entry&lt;K,V&gt; prev = table[i];</div><div class="line">        Entry&lt;K,V&gt; e = prev;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            Entry&lt;K,V&gt; next = e.next;</div><div class="line">            Object k;</div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">                modCount++;</div><div class="line">                size--;</div><div class="line">                <span class="keyword">if</span> (prev == e)</div><div class="line">                    table[i] = next;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    prev.next = next;</div><div class="line">                e.recordRemoval(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> e;</div><div class="line">            &#125;</div><div class="line">            prev = e;</div><div class="line">            e = next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> e;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>根据key获取hash 根据hash &amp; table.length - 1 获得key所在的桶中，到此桶中的链表遍历，如果key.euqals到某个结点，如果该结点正好在链表头结点，直接让table[i] = next,否则让删除结点的前置结点 = 删除结点的后置结点。</p><h4 id="7-元素的遍历"><a href="#7-元素的遍历" class="headerlink" title="7.元素的遍历"></a>7.元素的遍历</h4><p><img src="/2018/09/27/HashMap源码阅读记录/1.png" alt=""></p><h4 id="8-线程不安全的表现"><a href="#8-线程不安全的表现" class="headerlink" title="8.线程不安全的表现"></a>8.线程不安全的表现</h4><p>成环。</p><p><a href="http://www.importnew.com/22011.html" target="_blank" rel="external">http://www.importnew.com/22011.html</a></p><p><a href="https://www.cnblogs.com/dongguacai/p/5599100.html" target="_blank" rel="external">https://www.cnblogs.com/dongguacai/p/5599100.html</a></p><p><a href="https://www.jianshu.com/p/1e9cf0ac07f4" target="_blank" rel="external">https://www.jianshu.com/p/1e9cf0ac07f4</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line">       <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</div><div class="line">           <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</div><div class="line">               Entry&lt;K,V&gt; next = e.next;</div><div class="line">               <span class="keyword">if</span> (rehash) &#123;</div><div class="line">                   e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</div><div class="line">               e.next = newTable[i];</div><div class="line">               newTable[i] = e;</div><div class="line">               e = next;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>假设a-&gt;b-&gt;c链表在数组中，两个线程put操作导致扩容</p><p>假设线程2执行到Entry<k,v> next = e.next时被挂起，线程1继续执行，很不巧abc在rehash后又在同一位置，</k,v></p><p>1）先移动a到7位置（假设在7位置）</p><p>2）移动b此时 b-&gt;a</p><p>3）移动c此时 c-&gt;b-&gt;a（因为每次e.next = newTable[i],所以链表反转了）</p><p>此时线程1执行完，线程2唤醒，此时线程，1，2的引用关系如下：</p><p><img src="/2018/09/27/HashMap源码阅读记录/2.png" alt=""></p><p>此时：线程2被唤醒开始从断开的点执行，此时next指向b，e = a结点，执行循环中的逻辑</p><p>Entry<k,v> next = e.next;  //next此时为b</k,v></p><p>int i = indexFor(e.hash, newCapacity);</p><p>e.next = newTable[i];  //e = a.    e.next = null</p><p>newTable[i] = e;    //数组7位置为a</p><p>e = next;            //e = b–不为null再次执行循环逻辑</p><p>执行循环一次后的关系：此时e = b</p><p><img src="/2018/09/27/HashMap源码阅读记录/3.png" alt=""></p><p>执行完毕后e指向b（b的next结点为a因为线程1的关系导致的），再次执行循环此时</p><p>Entry<k,v> next = e.next;  //next此时为a</k,v></p><p>int i = indexFor(e.hash, newCapacity);</p><p>e.next = newTable[i];  //e = b.    e.next = a</p><p>newTable[i] = e;       //数组7位置为b-&gt;a</p><p>e = next;               //e = a–不为null再次执行循环逻辑</p><p>执行完这一次循环后e = a，非null此时引用关系：</p><p><img src="/2018/09/27/HashMap源码阅读记录/4.png" alt=""></p><p>由于e = a非空再次执行循环：</p><p>Entry<k,v> next = e.next;  //next此时为null</k,v></p><p>int i = indexFor(e.hash, newCapacity);//此时的newTable结点为b</p><p>e.next = newTable[i];  //e = a.    e.next = newTable = b</p><p>newTable[i] = e;       //数组7位置为a-&gt;b此时a又指向了b</p><p>e = next;               //e = null–为null结束循环</p><p>此时的引用关系：</p><p><img src="/2018/09/27/HashMap源码阅读记录/5.png" alt=""></p><p>链表出现了环，当再数组的该位置处get时就会死循环。另外，如果线程2把newTable设置成到内部的table，节点c的数据就丢了，还有数据遗失的问题。</p><p>所以在并发的情况，发生扩容时，可能会产生循环链表，在执行get的时候，会触发死循环，引起CPU的100%问题，所以一定要避免在并发环境下使用HashMap。</p><p>线程安全的HashMap：</p><p>Collections.synchronizedMap(map);</p><p><img src="/2018/09/27/HashMap源码阅读记录/6.png" alt=""></p><p>在每个方法内加synchronized锁对象。</p><h4 id="9-扩容为什么是2倍"><a href="#9-扩容为什么是2倍" class="headerlink" title="9.扩容为什么是2倍"></a>9.扩容为什么是2倍</h4><p>indexfor方法 = hash &amp; table.length - 1；</p><p>table.length 是2的幂次方，减去1 变为2进制是1111形式的，跟hash值取与操作可以让entry分布均匀，不为2的幂次方，有些entry可能永远不会被占用，分布均匀</p><p><a href="https://my.oschina.net/keyven/blog/1840583" target="_blank" rel="external">https://my.oschina.net/keyven/blog/1840583</a></p><p><img src="/2018/09/27/HashMap源码阅读记录/7.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、要点&quot;&gt;&lt;a href=&quot;#一、要点&quot; class=&quot;headerlink&quot; title=&quot;一、要点&quot;&gt;&lt;/a&gt;一、要点&lt;/h3&gt;&lt;p&gt;1.集合类的特点&lt;/p&gt;
&lt;p&gt;2.数据结构、初始化、构造器、初始参数&lt;/p&gt;
&lt;p&gt;3.元素的添加&lt;/p&gt;
&lt;p&gt;4.扩容
      
    
    </summary>
    
      <category term="java源码阅读记录" scheme="http://whk0710.github.io/categories/java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Stack源码阅读记录</title>
    <link href="http://whk0710.github.io/2018/09/27/Stack%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://whk0710.github.io/2018/09/27/Stack源码阅读记录/</id>
    <published>2018-09-27T08:38:26.000Z</published>
    <updated>2018-09-27T08:43:00.374Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、要点"><a href="#一、要点" class="headerlink" title="一、要点"></a>一、要点</h3><p>1.集合类的特点</p><p>2.数据结构、初始化、对象创建、构造器、初始参数</p><p>3.方法介绍</p><h3 id="二、源码解析（jdk1-8）"><a href="#二、源码解析（jdk1-8）" class="headerlink" title="二、源码解析（jdk1.8）"></a>二、源码解析（jdk1.8）</h3><h4 id="1-集合类的特点"><a href="#1-集合类的特点" class="headerlink" title="1.集合类的特点"></a>1.集合类的特点</h4><p>由源码可知：</p><p><img src="/2018/09/27/Stack源码阅读记录/1.png" alt=""></p><p>Stack继承自Vector，且类中没有其他数据结构和参数，所以栈底层也是通过数组实现，是线程安全的。满足栈的特性：先入后出。</p><h4 id="2-成员变量、常量、参数、构造器"><a href="#2-成员变量、常量、参数、构造器" class="headerlink" title="2.成员变量、常量、参数、构造器"></a>2.成员变量、常量、参数、构造器</h4><p>Stack只有默认构造器，new时先调用父类无参构造器，初始化一个大小10的数组。</p><h4 id="3-方法介绍"><a href="#3-方法介绍" class="headerlink" title="3.方法介绍"></a>3.方法介绍</h4><p>只有5个方法，pop、peek、search方法用synchronized修饰，线程安全。empty()就不说了，介绍4个。</p><p><strong>1）push</strong></p><p><img src="/2018/09/27/Stack源码阅读记录/2.png" alt=""></p><p>插入元素，直接调用父类的addElment方法，</p><p><img src="/2018/09/27/Stack源码阅读记录/3.png" alt=""></p><p>线程安全的方法，插入元素到数组末尾.</p><p><strong>2）pop</strong></p><p><img src="/2018/09/27/Stack源码阅读记录/4.png" alt=""></p><p>pop方法为删除并返回数组有效值的最后一个元素（也就是elementCount-1下标对应的值）调用removeElementAt方法，线程安全方法。</p><p><strong>3）peek</strong></p><p><img src="/2018/09/27/Stack源码阅读记录/5.png" alt=""></p><p>返回数组有效值的最后一个元素（也就是elementCount-1下标对应的值，线程安全方法。</p><p><strong>4）search</strong></p><p><img src="/2018/09/27/Stack源码阅读记录/6.png" alt=""></p><p>查找元素，调用父类lastIndexOf返回数组下标（size - i）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、要点&quot;&gt;&lt;a href=&quot;#一、要点&quot; class=&quot;headerlink&quot; title=&quot;一、要点&quot;&gt;&lt;/a&gt;一、要点&lt;/h3&gt;&lt;p&gt;1.集合类的特点&lt;/p&gt;
&lt;p&gt;2.数据结构、初始化、对象创建、构造器、初始参数&lt;/p&gt;
&lt;p&gt;3.方法介绍&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="java源码阅读记录" scheme="http://whk0710.github.io/categories/java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Vector源码阅读记录</title>
    <link href="http://whk0710.github.io/2018/09/27/Vector%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <id>http://whk0710.github.io/2018/09/27/Vector源码阅读记录/</id>
    <published>2018-09-26T23:52:43.000Z</published>
    <updated>2018-09-26T23:58:01.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源码解析（jdk1-8）（主要看跟ArrayList不一样的点）"><a href="#源码解析（jdk1-8）（主要看跟ArrayList不一样的点）" class="headerlink" title="源码解析（jdk1.8）（主要看跟ArrayList不一样的点）"></a>源码解析（jdk1.8）（主要看跟ArrayList不一样的点）</h3><h4 id="1-集合类的特点"><a href="#1-集合类的特点" class="headerlink" title="1.集合类的特点"></a>1.集合类的特点</h4><p>由源码可知：</p><p><img src="/2018/09/27/Vector源码阅读记录/1.png" alt=""></p><p>此类为List、RandomAccess, Cloneable, java.io.Serializable的实现类，支持连续内存存储（也就是数据结构为数组）、随机访问等跟ArrayList一样，区别在于，它是线程安全的可扩容线性列表；另外扩容数量不同（默认是2倍，如果指定了capacityIncrement就增加capacityIncrement这么多）。</p><h4 id="2-成员变量、常量、参数、构造器"><a href="#2-成员变量、常量、参数、构造器" class="headerlink" title="2.成员变量、常量、参数、构造器"></a>2.成员变量、常量、参数、构造器</h4><p>参数有：<img src="/2018/09/27/Vector源码阅读记录/2.png" alt=""></p><p>数据结构为一数组，表明Vector底层采用数组的数据结构实现</p><p><img src="/2018/09/27/Vector源码阅读记录/3.png" alt=""></p><p>elementCount表示数组中元素的个数，注释中说，数组的有效集合为0下标到elementCount-1下标</p><p><img src="/2018/09/27/Vector源码阅读记录/4.png" alt=""></p><p>capacityIncrement为容量增长幅度，新建Vector对象时可从构造器传入，与ArrayList不同的是，如果默认没指定capacityIncrement，扩容是变为原来的2倍，默认容量也是10.</p><p>构造器：<img src="/2018/09/27/Vector源码阅读记录/5.png" alt=""></p><p><img src="/2018/09/27/Vector源码阅读记录/6.png" alt=""></p><p>指定增长幅度与数组初始大小。</p><h4 id="3-元素的添加"><a href="#3-元素的添加" class="headerlink" title="3.元素的添加"></a>3.元素的添加</h4><p><img src="/2018/09/27/Vector源码阅读记录/7.png" alt=""></p><p>是线程安全的方法，先检查是否+1会超范围，是就调用grow扩容</p><p><img src="/2018/09/27/Vector源码阅读记录/8.png" alt=""></p><p><img src="/2018/09/27/Vector源码阅读记录/9.png" alt=""></p><p>判断是否预设了capacityIncrement，是就按照预设的值扩容，否就变为原来2倍，调用Arrays.copyof实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;源码解析（jdk1-8）（主要看跟ArrayList不一样的点）&quot;&gt;&lt;a href=&quot;#源码解析（jdk1-8）（主要看跟ArrayList不一样的点）&quot; class=&quot;headerlink&quot; title=&quot;源码解析（jdk1.8）（主要看跟ArrayList不一
      
    
    </summary>
    
      <category term="java源码阅读记录" scheme="http://whk0710.github.io/categories/java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>ArrayList源码阅读记录</title>
    <link href="http://whk0710.github.io/2018/08/26/ArrayList-source-code/"/>
    <id>http://whk0710.github.io/2018/08/26/ArrayList-source-code/</id>
    <published>2018-08-26T14:00:27.000Z</published>
    <updated>2018-09-26T14:24:40.578Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、要点"><a href="#一、要点" class="headerlink" title="一、要点"></a>一、要点</h3><p>1.集合类的特点</p><p>2.数据结构、初始化、对象创建、构造器、初始参数</p><p>3.元素的添加</p><p>4.元素的获取</p><p>5.元素的删除</p><p>6.元素的遍历</p><h3 id="二、源码解析（jdk1-7）"><a href="#二、源码解析（jdk1-7）" class="headerlink" title="二、源码解析（jdk1.7）"></a>二、源码解析（jdk1.7）</h3><h4 id="1-源码解析（jdk1-7）"><a href="#1-源码解析（jdk1-7）" class="headerlink" title="1.源码解析（jdk1.7）"></a>1.源码解析（jdk1.7）</h4><p>由源码可知：</p><p><img src="/2018/08/26/ArrayList-source-code/1.png" alt=""></p><p>此集合类继承AbstractList、实现List<e>, RandomAccess, Cloneable，Serializable，表明此类具有LIst（和数组）的特性，并且支持动态分配数组大小、随机访问，实现Cloneable表明：</e></p><p><img src="/2018/08/26/ArrayList-source-code/2.png" alt=""></p><p>该类的对象可以通过clone()方法进行拷贝，支持序列化。尾部插入快、随机读取快，删除，中间插入、删除慢.</p><h4 id="2-成员变量、常量、参数、构造器"><a href="#2-成员变量、常量、参数、构造器" class="headerlink" title="2.成员变量、常量、参数、构造器"></a>2.成员变量、常量、参数、构造器</h4><p>参数有：</p><p><img src="/2018/08/26/ArrayList-source-code/3.png" alt=""></p><p>此成员变量表明，arraylist底层数据结构是由数组实现，用transient修饰表示序列化时，此变量不会序列化.</p><p><img src="/2018/08/26/ArrayList-source-code/4.png" alt=""></p><p>此变量为当前数组的大小（the number of elements it contains）</p><p><img src="/2018/08/26/ArrayList-source-code/5.png" alt=""></p><p>此常量为，该list包含数组元素的最大值.</p><p>构造函数：</p><p><strong>1）无参构造器</strong></p><p><img src="/2018/08/26/ArrayList-source-code/6.png" alt=""></p><p>调用public ArrayList(int initialCapacity) 构造器实现默认创建elementData为大小<strong><em>10</em></strong>的数组</p><p><strong>2）public ArrayList(int initialCapacity)构造器</strong></p><p><img src="/2018/08/26/ArrayList-source-code/7.png" alt=""></p><p>传入一个包含特定对象的集合类，把这个集合类对象转为arraylist，首先会将此集合类转为数组，将此数组赋值给elementData，判断此数组是否为Object类数组对象，如果不是，通过Arrays.copyOf方法将其转为Object数组对象（注释中说，调用c.toArray方法可能返回的不是object类型）.</p><h4 id="3-arraylist的add方法与set方法"><a href="#3-arraylist的add方法与set方法" class="headerlink" title="3.arraylist的add方法与set方法"></a>3.arraylist的add方法与set方法</h4><p><strong>1）boolean add(E e)</strong></p><p><img src="/2018/08/26/ArrayList-source-code/8.png" alt=""></p><p>直接添加元素，调用ensureCapacityInternal判断当前size+1会不会超过默认或自己只当的capacity；让elementData数组的第size位 = 这个新加入的元素，size++；每添加一个元素，size加1.</p><p><img src="/2018/08/26/ArrayList-source-code/9.png" alt=""></p><p>如果size+1大小超过了当前数组的默认或自己指定的length，则调用grow方法扩容（注意size和length是不同的，length是数组的length（默认为10或自己指定了），size是数组中元素的个数）.</p><p><img src="/2018/08/26/ArrayList-source-code/10.png" alt=""></p><p>grow方法，首先计算新的数组length = 原数组length + 原数组length 右移1位，也就是容量扩大为原来的1.5倍。然后判断此新容量跟传入的minCapacity比较如果新值小于此数，就直接扩容为minCapacity大小，</p><p><img src="/2018/08/26/ArrayList-source-code/11.png" alt=""></p><p>如果新容量大于最大限制阈值，会让新容量根据hugeCapacity判断选择容量：如果minCapacity大于了最大限制阈值，新容量 = int最大值，否则，新容量 = 最大限制阈值。</p><p><strong>2）E set(int index, E element)方法</strong></p><p><img src="/2018/08/26/ArrayList-source-code/12.png" alt=""></p><p>将对应下标的元素设置为新值，并返回旧值，首先检查输入的index是否大于size，大于就抛异常：</p><p><img src="/2018/08/26/ArrayList-source-code/13.png" alt=""></p><p>否则就获取旧值，将index下的值 = 新传入的值，返回刚才获取的旧值.</p><p><strong>3）void add(int index, E element)</strong></p><p><img src="/2018/08/26/ArrayList-source-code/14.png" alt=""></p><p>指定位置插入元素，线性时间复杂度。首先检查输入的index范围是否大于0并小于size，否则抛异常：</p><p><img src="/2018/08/26/ArrayList-source-code/15.png" alt=""></p><p>符合范围，就判断是否size+1超过length，超过就扩容。然后调用System.arraycopy(elementData, index, elementData, index + 1, size - index);方法，将原来index位置起的元素向后移动（每一个index后的元素向后移动一位）空出index出，然后将elementData[index] = element;并且size++。</p><p><strong>4）boolean addAll(Collection&lt;? extends E&gt; c)</strong></p><p><img src="/2018/08/26/ArrayList-source-code/16.png" alt=""></p><p>将传入的集合类对象中的全部元素插入list中，首先将集合类对象转为数组a，判断是否超出length，超出扩容，调用System.arraycopy(a, 0, elementData, size, numNew);将数组a拷贝到elementData数组，System.arraycopy(Objec src,int srcPos,Object desc,int descPos,int length)意思是将从第0位开始的a数组中的全部元素，copy到elementData数组的size下标后，也就是将a插入到elementData数组的尾部。</p><p><strong>5）boolean addAll(int index, Collection&lt;? extends E&gt; c)</strong></p><p><img src="/2018/08/26/ArrayList-source-code/17.png" alt=""></p><p>从index处将整个集合类插入到elementData数组，是需要将原数组index处元素后移集合类的length位置。</p><h4 id="4-元素的获取get方法"><a href="#4-元素的获取get方法" class="headerlink" title="4.元素的获取get方法"></a>4.元素的获取get方法</h4><p><img src="/2018/08/26/ArrayList-source-code/18.png" alt=""></p><p>检查是否输入的index比size大等，是抛异常，否则返回elementData[index]</p><p><img src="/2018/08/26/ArrayList-source-code/19.png" alt=""></p><h4 id="5-元素的删除"><a href="#5-元素的删除" class="headerlink" title="5.元素的删除"></a>5.元素的删除</h4><p><strong>1）E remove(int index)</strong></p><p>移除指定位置的元素，返回旧值。线性时间复杂度</p><p><img src="/2018/08/26/ArrayList-source-code/20.png" alt=""></p><p>检查范围，如果index&gt;=size抛异常，否则，获取index旧值，保存以用于返回，计算需要移动的元素个数，将index处之后的所有元素向前移动一位，并将size减一.</p><p><strong>2）boolean remove(Object o)</strong></p><p><img src="/2018/08/26/ArrayList-source-code/21.png" alt=""></p><p>移除指定元素，时间复杂度n^2？，会移除null元素，遍历数组判断输入的对象是否为空，为空调用fastRemove方法移除，不为空，通过equals方法判断是否有此元素，有也是调用fastRemove删除：</p><p><img src="/2018/08/26/ArrayList-source-code/22.png" alt=""></p><p>嗯？？？这不是remove（index）中的代码吗，，，这个程序员不合格，又重新写了一边。。思路就是先计算需要移动的元素个数，调用system.arraycopy将index处以后的元素每个向前移动一位，将size处的元素赋值为null，size–</p><p><strong>3）void clear()方法</strong></p><p><img src="/2018/08/26/ArrayList-source-code/23.png" alt=""></p><p>作用是将数组每个元素置空，移除所有元素，简单粗暴，直接遍历赋值，并将size=0，牛逼。</p><p><strong>4）void removeRange(int fromIndex, int toIndex)</strong></p><p>移除指定范围的元素，线性时间复杂度</p><p><img src="/2018/08/26/ArrayList-source-code/243.png" alt=""></p><p>首先获取要移动的元素个数，然后调用system.arrycopy方法将elementData的toIndex处及以后的元素赋值到elementData的fromIndex以及以后的位置。然后给不需要的元素赋值空，size变化。</p><p><strong>5）boolean removeAll(Collection&lt;?&gt; c)</strong></p><p><img src="/2018/08/26/ArrayList-source-code/25.png" alt=""></p><p><img src="/2018/08/26/ArrayList-source-code/26.png" alt=""></p><p>移除输入集合类的元素</p><h4 id="6-遍历"><a href="#6-遍历" class="headerlink" title="6.遍历"></a>6.遍历</h4><p><strong>1）迭代器遍历</strong></p><p><img src="/2018/08/26/ArrayList-source-code/27.png" alt=""></p><p>new Itr实现，Itr内部类：</p><p><img src="/2018/08/26/ArrayList-source-code/28.png" alt=""></p><p><img src="/2018/08/26/ArrayList-source-code/29.png" alt=""></p><p>cursor表示当前遍历到的index游标，hasNext判断当前cursor是否等于size，等于返回false，表示已遍历完，否则还没遍历完</p><p>next方法：思路就是，记录原来cursor，让当前cursor+1，然后返回数组中原cursor处的元素</p><p>remove方法：思路是调用arraylist的remove(index)方法，并改变cursor.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、要点&quot;&gt;&lt;a href=&quot;#一、要点&quot; class=&quot;headerlink&quot; title=&quot;一、要点&quot;&gt;&lt;/a&gt;一、要点&lt;/h3&gt;&lt;p&gt;1.集合类的特点&lt;/p&gt;
&lt;p&gt;2.数据结构、初始化、对象创建、构造器、初始参数&lt;/p&gt;
&lt;p&gt;3.元素的添加&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="java源码阅读记录" scheme="http://whk0710.github.io/categories/java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>面试与笔试</title>
    <link href="http://whk0710.github.io/2018/06/04/%E6%89%BE%E5%B7%A5%E4%BD%9C%E5%87%86%E5%A4%87/"/>
    <id>http://whk0710.github.io/2018/06/04/找工作准备/</id>
    <published>2018-06-04T02:59:02.000Z</published>
    <updated>2018-06-04T03:07:16.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h1><ul><li>深入理解JVM虚拟机（周志明，第二版）</li><li>数据结构（最好是java版，推荐《数据结构与算法分析java语言描述，第二版》）</li><li>设计模式（推荐《大话设计模式》、《HeadFirst设计模式》）</li><li>Spring in action，第四版</li><li>计算机网络</li><li>数据库</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;知识储备&quot;&gt;&lt;a href=&quot;#知识储备&quot; class=&quot;headerlink&quot; title=&quot;知识储备&quot;&gt;&lt;/a&gt;知识储备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;深入理解JVM虚拟机（周志明，第二版）&lt;/li&gt;
&lt;li&gt;数据结构（最好是java版，推荐《数据结构与算法分析j
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring study</title>
    <link href="http://whk0710.github.io/2018/04/11/Spring-study/"/>
    <id>http://whk0710.github.io/2018/04/11/Spring-study/</id>
    <published>2018-04-11T13:13:46.000Z</published>
    <updated>2018-04-11T13:24:18.027Z</updated>
    
    <content type="html"><![CDATA[<p>Spring in action 第四版学习笔记—第一章</p><p>刚开始看这本书，感觉有很多概念并不懂，于是将不懂的概念一一搜了一下，先记录一些相关名词的意思。</p><ul><li><p>这本书一上来就提到了EJB(Enterprise JavaBean)，直译的话就是企业级JavaBean，但是JavaBean又是什么呢，</p></li><li><p>POJO(Plain old Java Object)，直译为普通旧式java对象，人们常常翻译为简单java对象</p></li></ul><h2 id="1、依赖注入"><a href="#1、依赖注入" class="headerlink" title="1、依赖注入"></a>1、依赖注入</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring in action 第四版学习笔记—第一章&lt;/p&gt;
&lt;p&gt;刚开始看这本书，感觉有很多概念并不懂，于是将不懂的概念一一搜了一下，先记录一些相关名词的意思。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这本书一上来就提到了EJB(Enterprise JavaBean)，直译
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>奇妙的八卦</title>
    <link href="http://whk0710.github.io/2017/11/16/%E5%A5%87%E5%A6%99%E7%9A%84%E5%85%AB%E5%8D%A6/"/>
    <id>http://whk0710.github.io/2017/11/16/奇妙的八卦/</id>
    <published>2017-11-16T03:08:48.000Z</published>
    <updated>2017-11-16T03:24:37.651Z</updated>
    
    <content type="html"><![CDATA[<p>我对一些数字比较感兴趣，比如1,2,3,4,5,8,10,12,24这几个数字。</p><p>1，一天、一年、一个月、一个人…；2，男女、日月、天地、水火…；3，早中晚、天人地…；4，四季…；5，五行…;8，八卦…；10，10天干；12，一年12个月、一天12个时辰、12地支…；24,24个节气…</p><p>道德经曰：“道生一，一生二，二生三，三生万物”；易经曰：“是故，易有太极，是生两仪，两仪生四象，四象生八卦，八卦定吉凶，吉凶生大业。”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我对一些数字比较感兴趣，比如1,2,3,4,5,8,10,12,24这几个数字。&lt;/p&gt;
&lt;p&gt;1，一天、一年、一个月、一个人…；2，男女、日月、天地、水火…；3，早中晚、天人地…；4，四季…；5，五行…;8，八卦…；10，10天干；12，一年12个月、一天12个时辰、12
      
    
    </summary>
    
      <category term="玄学杂谈" scheme="http://whk0710.github.io/categories/%E7%8E%84%E5%AD%A6%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建静态博客</title>
    <link href="http://whk0710.github.io/2017/11/15/Hexo-Github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>http://whk0710.github.io/2017/11/15/Hexo-Github搭建静态博客/</id>
    <published>2017-11-15T13:14:58.000Z</published>
    <updated>2018-07-14T06:51:39.780Z</updated>
    
    <content type="html"><![CDATA[<h3 id="假装是个标题"><a href="#假装是个标题" class="headerlink" title="假装是个标题"></a>假装是个标题</h3><p>首先说一下为什么写这么个博客，在网上你可以搜到一大堆教你如何用hexo搭建博客的教程。</p><p>那我为什么还要写呢？</p><p>很简单，我是为了练习一下markdown语法、顺便记录一下自己搭博客的心路历程吧，虽然挺简单的。</p><p>我想先吐槽一下，为啥我的段落行间距这么大呢，看了一下我用的主题css文件里，p标签的margin属性上下不是0，这主题就这样吧，保持原汁原味吧不改了。</p><h3 id="开始吧"><a href="#开始吧" class="headerlink" title="开始吧"></a>开始吧</h3><p>首先你需要准备一下：</p><ol><li>一个可以用的github账号，<a href="https://github.com/" target="_blank" rel="external">注册地址</a></li><li>安装git软件,32或64取决于你的电脑，<a href="https://git-scm.com/download/win" target="_blank" rel="external">下载地址</a>，好像有的时候这个网站登陆不了，可以直接在百度下载…</li><li>Node.js,32或64取决于你的电脑系统，<a href="https://nodejs.org/zh-cn/download/releases/" target="_blank" rel="external">下载地址</a></li><li>一台差不多的电脑</li></ol><p>准备完毕后，好，开搞。</p><p>登陆<a href="https://github.com/" target="_blank" rel="external">github网站</a>，点击new repository创建新仓库，页面以及仓库名如下图：<br><img src="/2017/11/15/Hexo-Github搭建静态博客/new_repo.png" alt=""></p><p>其他的都不管，直接点击create repository。create完了之后等一段时间登陆一下<a href="http://你的用户名.github.io" target="_blank" rel="external">http://你的用户名.github.io</a> 你会看到如下页面：</p><p><img src="/2017/11/15/Hexo-Github搭建静态博客/gitbash.png" alt=""></p><h3 id="git的安装及配置"><a href="#git的安装及配置" class="headerlink" title="git的安装及配置"></a>git的安装及配置</h3><p>git软件安装的时候可以一路默认next。</p><p>安装完成后，在随便一个位置点击鼠标右键，点击”git bash here”，会出现一个类似于linux终端的东西，接下来我们需要配置一下，在这个命令行中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name &quot;你的github用户名&quot;</div><div class="line">git config --global user.email &quot;你github的邮箱&quot; //注意引号必须要写</div></pre></td></tr></table></figure><p>接下来我们要配置SSH，个人理解，我觉得配置SSH主要是避免每次诚提交代码到github都要输入账号密码，使用SSH方便、加密技术牛逼很安全。</p><p>如果你是第一次安装使用git，在git bash中输入 ，依次点击enter，一共三次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-kengen -t rsa -C &quot;你注册github的邮件地址&quot;</div></pre></td></tr></table></figure><p><img src="/2017/11/15/Hexo-Github搭建静态博客/key.png" alt=""></p><p>在bash命令行中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd ~/.ssh   //这是进入用户目录下的.ssh文件夹</div><div class="line">ls   //查看这个目录下的文件</div><div class="line">cat id_rsa.pub  //查看这个文件的内容</div></pre></td></tr></table></figure><p>之后你会看见：</p><p><img src="/2017/11/15/Hexo-Github搭建静态博客/rsa.png" alt=""></p><p>复制从”ssh-rsa ………….”到”邮箱地址xx@xx.xx”这一段，然后转到你的github中，点击右上角的设置图标，然后点击左侧的SSH and GPG keys，之后点击New SSH key</p><p><img src="/2017/11/15/Hexo-Github搭建静态博客/set.png" alt=""></p><p><img src="/2017/11/15/Hexo-Github搭建静态博客/ssh.png" alt=""></p><p><img src="/2017/11/15/Hexo-Github搭建静态博客/addkey.png" alt=""></p><p>title可以随便取，key中填写刚刚复制的那一段，然后点击add ssh key，之后输密码，完成。</p><p>为了测试一下，我们的电脑是否可以正确通过SSH访问github，可以在git bash命令行中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure><p>若跟下图类似有Hi xxx You’ve successfully…，表明配置成功。（报错的可以重新试一下）</p><p><img src="/2017/11/15/Hexo-Github搭建静态博客/suc.png" alt=""></p><h3 id="hexo的安装与配置"><a href="#hexo的安装与配置" class="headerlink" title="hexo的安装与配置"></a>hexo的安装与配置</h3><p>接下来我们要先安装刚下载的Nodejs软件，一路next即可。</p><p>随后我们在一个盘里创建一个文件夹例如：E:\blog，进入此文件夹，右键点击选择”git bash here”(或shift+右键打开cmd)，之后在命令行中输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;假装是个标题&quot;&gt;&lt;a href=&quot;#假装是个标题&quot; class=&quot;headerlink&quot; title=&quot;假装是个标题&quot;&gt;&lt;/a&gt;假装是个标题&lt;/h3&gt;&lt;p&gt;首先说一下为什么写这么个博客，在网上你可以搜到一大堆教你如何用hexo搭建博客的教程。&lt;/p&gt;
&lt;p&gt;那我为
      
    
    </summary>
    
      <category term="不技术的技术" scheme="http://whk0710.github.io/categories/%E4%B8%8D%E6%8A%80%E6%9C%AF%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>自勉</title>
    <link href="http://whk0710.github.io/2017/09/14/%E8%87%AA%E5%8B%89/"/>
    <id>http://whk0710.github.io/2017/09/14/自勉/</id>
    <published>2017-09-14T03:22:54.000Z</published>
    <updated>2017-09-14T03:23:19.885Z</updated>
    
    <content type="html"><![CDATA[<p>如果你从前荒废了，再怎么努力也不可能打败那些从一开始就一直努力的人，但我们不是为了打败他们而努力，<br>我们是为了不被那些不需要努力就可以生存得很好的人打败而努力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果你从前荒废了，再怎么努力也不可能打败那些从一开始就一直努力的人，但我们不是为了打败他们而努力，&lt;br&gt;我们是为了不被那些不需要努力就可以生存得很好的人打败而努力。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
